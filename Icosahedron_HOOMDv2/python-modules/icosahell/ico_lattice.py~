import numpy as np, sys, math

# Attempts to generate a lattice that corresponds to the icosahedral structure.
sqrt3 = math.sqrt(3.0)
    
a1 = np.array( [ 0.0, 0.0, 1.0 ] )
a2 = np.array( [ sqrt3, 0.0, -1 ] )*0.5
a3 = np.array( [ sqrt3, 0.0,  1 ] )*0.5
    
def generate_skel():
    """ Generates the skeleton (T1 structure). """

    N = 20
    X = np.zeros( [ N, 3], dtype = float )
    signs = np.zeros( N, dtype = float )
    X[0] = [ 0, 0, 0 ]
    signs[0] = -1
    for i in range(1,10,2):
        X[i]   = X[i-1] + a2
        X[i+1] = X[i]   + a3
        signs[i]   =  1
        signs[i+1] = -1
        

    offset = 10
    for i in range(0, 10, 2):
        X[ offset + i ]     = X[i]   + a1
        X[ offset + i + 1 ] = X[i+1] - a1
        signs[offset + i] = 1
        signs[offset + i+1] = -1
        
    return X, signs

def generate_lines( Xc, signs ):
    """ Generates the triangle lines. """
    b1 = np.array( [ 1.0, 0.0, 0.0 ] )
    b2 = np.array( [ 1.0, 0.0, sqrt3 ] )*0.5
    b3 = np.array( [ -1.0, 0.0, sqrt3 ] )*0.5

    d1 = np.array( [  0.5, 0.0, -sqrt3 / 6.0 ] )*sqrt3
    d2 = np.array( [  0.0, 0.0,  sqrt3 / 3.0 ] )*sqrt3
    d3 = np.array( [ -0.5, 0.0, -sqrt3 / 6.0 ] )*sqrt3

    Nc = len(Xc)
    X = np.zeros( [Nc*3,3], dtype = float )

    j = 0
    for i in range(0, 10,2):
        xx = Xc[i]
        # First not upright, second is.
        s = signs[i]
        e1 = xx + s*d1
        e2 = xx + s*d2
        e3 = xx + s*d3
        X[j] = e1
        X[j+1] = e2
        X[j+2] = e3
        
        xx = Xc[i+1]
        s = signs[i+1]
        e1 = xx + s*d1
        e2 = xx + s*d2
        e3 = xx + s*d3
        X[j+3] = e1
        X[j+4] = e2
        X[j+5] = e3

        j += 6

    for i in range(10,20, 2):
        xx = Xc[i]
        # First not upright, second is.
        s = signs[i]
        e1 = xx + s*d1
        e2 = xx + s*d2
        e3 = xx + s*d3
        X[j] = e1
        X[j+1] = e2
        X[j+2] = e3
        
        xx = Xc[i+1]
        s = signs[i+1]
        e1 = xx + s*d1
        e2 = xx + s*d2
        e3 = xx + s*d3
        X[j+3] = e1
        X[j+4] = e2
        X[j+5] = e3

        j += 6
        
    return X


def decorate_with( Xc, signs, template ):
    """ Decorates the lattice Xc with template. """
    Nl = len(Xc)
    Nt = len(template)
    Ntotal = Nt*Nl
    print( "Generating", Ntotal, "points.", file = sys.stderr )
    Xn = np.zeros( [ Ntotal, 3 ], dtype = float )
    for i in range(0, Nl):
        for j in range(0, Nt):
            idx = i*Nt + j
            Xn[idx] = Xc[i] + template[j]*signs[i]
    return Xn

if __name__ == "__main__":
    """ """
    Xc, signs = generate_skel()
    Xl = generate_lines( Xc, signs )
    c = 0
    
    # Xc contains center of mass of triangle, sign is
    # -1 if it points down and +1 if it points up.

    with open("centers.dat", "w") as fp:
        for xx in Xc:
            print(xx[0], xx[1], xx[2], c, file = fp)
            c += 1.0

    with open("edges.dat", "w") as fp:
        lc = 0
        xtmp = [0, 0, 0]
        for xx in Xl:
            if lc == 0:
                xtmp[0] = xx[0]
                xtmp[1] = xx[1]
                xtmp[2] = xx[2]
            print(xx[0], xx[1], xx[2], file = fp)
            lc += 1
            if lc == 3:
                print( xtmp[0], xtmp[1], xtmp[2], file = fp )
                print("", file = fp)
                print("", file = fp)
                lc = 0
    template = np.array( [ [-0.2, 0,  0.0],
                           [ 0.2, 0,  0.0],
                           [ 0.0, 0, -0.2],
                           [ 0.0, 0,  0.2],
                           [ 0.2, 0, 0.2 ] ] )
    Xt = decorate_with( Xc, signs, template )
    for xx in Xt:
        print( xx[0], xx[1], xx[2] )
