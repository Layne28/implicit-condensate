import numpy as np
import math
import sys
import copy
import numbers

class quat:
    """ A simple quaternion class. """

    def __init__(self, r = None, u = None, v = None, w = None):
        """ Constructor. """
        if r is None and u is None and v is None and w is None:
            self.r = 1.0
            self.u = 0.0
            self.v = 0.0
            self.w = 0.0

        if r is not None:
            if u is None and v is None and w is None:
                try:
                    if len(r) == 3:
                        self.r = 0
                        self.u = r[0]
                        self.v = r[1]
                        self.w = r[2]
                    elif len(r) == 4:
                        self.r = r[0]
                        self.u = r[1]
                        self.v = r[2]
                        self.w = r[3]
                    elif len(r) == 1:
                        self.r = r[0]
                        self.u = 0
                        self.v = 0
                        self.w = 0
                    else:
                        raise RuntimeError("Can only instantiate from iterable "
                                           "of size 3 or 4!")
                except TypeError:
                    self.r = float(r)
                    self.u = 0.0
                    self.v = 0.0
                    self.w = 0.0
            elif u is not None and v is not None and w is not None:
                self.r = float(r)
                self.u = float(u)
                self.v = float(v)
                self.w = float(w)
            else:
                raise RuntimeError("Instantiate quaternion with a real number, "
                                   "an iterable of length 3 or 4 or four "
                                   "numbers!")

    def __add__(self, other):
        """ Addition. """
        qret = quat( self.r + other.r,
                     self.u + other.u,
                     self.v + other.v,
                     self.w + other.w )
        
        return qret

    def __sub__(self,other):
        """ Subtraction. """
        qret = quat( self.r - other.r,
                     self.u - other.u,
                     self.v - other.v,
                     self.w - other.w )
        
        return qret

    def __mul__( self, other ):
        """ Quaternion multiplication. """
        a1 = copy.copy(self.r)
        b1 = copy.copy(self.u)
        c1 = copy.copy(self.v)
        d1 = copy.copy(self.w)
        a2 = copy.copy(other.r)
        b2 = copy.copy(other.u)
        c2 = copy.copy(other.v)
        d2 = copy.copy(other.w)

        qret = quat(
            a1*a2 - b1*b2 - c1*c2 - d1*d2,
            a1*b2 + b1*a2 + c1*d2 - d1*c2,
            a1*c2 - b1*d2 + c1*a2 + d1*b2,
            a1*d2 + b1*c2 - c1*b2 + d1*a2
        )

        return qret

    
    def __div__( self, scalar ):
        """ Quaternion division by scalar. """
        self.r /= scalar
        self.u /= scalar
        self.v /= scalar
        self.w /= scalar

        return self


    def __truediv__( self, scalar ):
        return self.__div__(scalar)

    
    def __getitem__( self, idx ):
        """ Indexed access. """
        if idx < 0 or idx > 3:
            raise RuntimeError("Index out of bounds!")

        if idx == 0:
            return self.r
        elif idx == 1:
            return self.u
        elif idx == 2:
            return self.v
        elif idx == 3:
            return self.w
        
    def __setitem__( self, idx, value ):
        """ Indexed access. """
        if idx < 0 or idx > 3:
            raise RuntimeError("Index out of bounds!")

        if idx == 0:
            self.r = value
        elif idx == 1:
            self.u = value
        elif idx == 2:
            self.v = value
        elif idx == 3:
            self.w = value

    def __repr__( self ):
        """ Representation of quaternion. """
        return "quat( {}, {}, {}, {} )".format(self.r, self.u, self.v, self.w)

    def __str__( self ):
        """ Pretty-print quaternion. """
        return "[{} {} {} {}]".format(self.r, self.u, self.v, self.w)


    def t(self):
        """ Complex conjugate """
        qret = quat( self.r,
                     -self.u,
                     -self.v,
                     -self.w )
        return qret

    def inv(self):
        """ Inverse """
        n2 = self.norm2()
        qret = self.t() / n2
        return qret

    def norm2(self):
        """ Squared norm of quaternion. """
        r = self.r
        u = self.u
        v = self.v
        w = self.w
        return r*r + u*u + v*v + w*w

    def norm(self):
        """ Norm of quaternion. """
        return math.sqrt( self.norm2() )

    def init_from_spherical(self, x, y, z):
        R2 = x*x + y*y + z*z
        R  = math.sqrt(R2)
        self.r = 0
        self.u = x / R
        self.v = y / R
        self.w = z / R

        return self



def rot_vector( v, axis, angle ):
    """ Rotates given vector v about axis with given angle. """

    # Normalize the vectors:
    axis /= np.linalg.norm(axis)

    q1 = quat( 0, v[0], v[1], v[2] )
    
    s = math.sin(angle/2.0)
    c = math.cos(angle/2.0)
    
    rotator = quat( c, axis[0]*s, axis[1]*s, axis[2]*s )
   
    qrr = rotator * q1
    rotator = rotator.t()
    qr = qrr*rotator

    # Check:
    if abs(qr[0]) > 1e-8:
        print("Real part of rotated quaternion too large! ", qr[0],
              " > ", 1e-8, file = sys.stderr)
    
    vrot = np.array( [ qr[1], qr[2], qr[3] ] )

    return vrot
    
        
    
def test_quat():
    """ !Simple test for quaternions. """

    q1 = quat()
    q2 = quat(1,2,3,4)

    q3 = q1 + q2
    q4 = q1 - q2

    print(q1)
    print(q2)
    print(q3)
    print(q4)
            
    q5 = quat().init_from_spherical( 0, 0, 1 )
    q6 = quat().init_from_spherical( 0, 1, 0 )
    print(q5)
    print(q6)

    # To see if it works as expected, rotate q5 over q6 with
    # 90 degrees, should get -e_x.
    print("(0, 0, 1) about (0, 1, 0) with pi")
    v = rot_vector( np.array( [ 0., 0, 1 ] ), np.array( [ 0., 1, 0 ] ), math.pi )
    print("Got       %f %f %f" % (v[0], v[1], v[2]))
    print("Should be %f %f %f" % (0, 0, -1))

    print("")
    print("(0, 0, 1) about (0, 1, 0) with pi/2")
    v = rot_vector( np.array( [ 0., 0, 1 ] ), np.array( [ 0., 1, 0 ] ), math.pi/2.0 )
    print("Got       %f %f %f" % (v[0], v[1], v[2]))
    print("Should be %f %f %f" % (1,0,0))

    print("")
    print("(0, 0, 1) about (1, 1, 0) with pi")
    v = rot_vector( np.array( [ 0, 0, 1. ] ), np.array( [ 1., 1, 0 ] ), math.pi )
    print("Got       %f %f %f" % (v[0], v[1], v[2]))
    print("Should be %f %f %f" % (0, 0, -1))

    q = quat(1,2,3,4)
    p = quat(5,4,3,2)

    print("q        =", q)
    print("|q|      =", q.norm())
    print("q^T      =", q.t())
    print("q^-1     =", q.inv())
    print("q*q^T    =",q*q.t())
    print("q*q^-1   =",q*q.inv())
    print("")
    print("p          =", p)
    print("|p|        =", p.norm())
    qp = q*p
    qpqi = qp*q.inv()
    print("q*p        =", qp)
    print("q*p*q^-1   =", qp*q.inv())
    print("q*p*q^-1   =", q*p*q.inv())
    print("|q*p*q^-1| =", qpqi.norm())
    
if __name__ == "__main__":
    """Run the test."""
    test_quat()
